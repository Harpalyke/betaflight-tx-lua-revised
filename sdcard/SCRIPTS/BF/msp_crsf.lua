MSP_VERSION=bit32.lshift(1,5)MSP_STARTFLAG=bit32.lshift(1,4)CRSF_ADDRESS_BETAFLIGHT=0xC8;CRSF_ADDRESS_RADIO_TRANSMITTER=0xEA;CRSF_FRAMETYPE_MSP_REQ=0x7A;CRSF_FRAMETYPE_MSP_RESP=0x7B;CRSF_FRAMETYPE_MSP_WRITE=0x7C;MSP_TX_PAYLOAD_SIZE=8;MSP_RX_PAYLOAD_SIZE=58;local a=0;local b=0;local c=0;local d={}local e={}local f=1;local g=0;local h=false;local i=0;local j=false;mspRequestsSent=0;mspRepliesReceived=0;mspPkRxed=0;mspErrorPk=0;mspStartPk=0;mspOutOfOrder=0;mspCRCErrors=0;mspPendingRequest=false;local function k()mspRequestsSent=0;mspRepliesReceived=0;mspPkRxed=0;mspErrorPk=0;mspStartPk=0;mspOutOfOrderPk=0;mspCRCErrors=0 end;local l={}local m=1;local n=0;local o=0;local function p(q)local r={CRSF_ADDRESS_BETAFLIGHT,CRSF_ADDRESS_RADIO_TRANSMITTER}for s=1,#q do r[s+2]=q[s]end;if j then local t=io.open(logFile,"a")local u=string.format("TX:0x%0X,",c)if t then for s=1,#r do u=u..string.format("0x%0X",r[s])if s<#r then u=u..","end end end;u=u.."\n"io.write(t,u)io.close(t)end;crossfireTelemetryPush(c,r)o=o+1 end;function mspProcessTxQ()if#l==0 then return false end;if not crossfireTelemetryPush()then return true end;local q={}q[1]=a+MSP_VERSION;a=bit32.band(a+1,0x0F)if m==1 then q[1]=q[1]+MSP_STARTFLAG end;local s=2;while s<=MSP_TX_PAYLOAD_SIZE do if m>#l then break end;q[s]=l[m]m=m+1;n=bit32.bxor(n,q[s])s=s+1 end;if s<=MSP_TX_PAYLOAD_SIZE then q[s]=n;s=s+1;while s<=MSP_TX_PAYLOAD_SIZE do q[s]=0;s=s+1 end;p(q)l={}m=1;n=0;return false end;p(q)return true end;function mspReadPackage(v)c=CRSF_FRAMETYPE_MSP_REQ;return mspSendRequest(v,{})end;function mspWritePackage(v,q)c=CRSF_FRAMETYPE_MSP_WRITE;return mspSendRequest(v,q)end;function mspSendRequest(v,q)if#l~=0 or not v then return nil end;l[1]=#q;l[2]=bit32.band(v,0xFF)for s=1,#q do l[s+2]=bit32.band(q[s],0xFF)end;i=v;mspRequestsSent=mspRequestsSent+1;return mspProcessTxQ()end;local function w(q)mspPkRxed=mspPkRxed+1;local x=1;local y=q[x]local z=bit32.band(y,0x20)~=0;x=x+1;if z then h=false;mspErrorPk=mspErrorPk+1;return nil end;local A=bit32.band(y,0x10)~=0;local B=bit32.band(y,0x0F)if A then f=1;e={}mspRxSize=q[x]g=bit32.bxor(mspRxSize,i)x=x+1;h=true;mspStartPk=mspStartPk+1 elseif not h then mspOutOfOrder=mspOutOfOrder+1;return nil elseif bit32.band(b+1,0x0F)~=B then mspOutOfOrder=mspOutOfOrder+1;h=false;return nil end;while x<=MSP_RX_PAYLOAD_SIZE and f<=mspRxSize do e[f]=q[x]g=bit32.bxor(g,q[x])f=f+1;x=x+1 end;if x>MSP_RX_PAYLOAD_SIZE then b=B;return true end;if g~=q[x]then h=false;mspCRCErrors=mspCRCErrors+1;return nil end;mspRepliesReceived=mspRepliesReceived+1;h=false;return e end;function mspPollReply()while true do local C,D=crossfireTelemetryPop()if j and C then local t=io.open(logFile,"a")local u=string.format("RX:0x%0X,",C)if t then for s=1,#D do u=u..string.format("0x%0X",D[s])if s<#D then u=u..","end end end;u=u.."\n"io.write(t,u)io.close(t)end;if C==CRSF_FRAMETYPE_MSP_RESP then if D[1]==CRSF_ADDRESS_RADIO_TRANSMITTER and D[2]==CRSF_ADDRESS_BETAFLIGHT then local E={}for s=3,#D do E[s-2]=D[s]end;local F=w(E)if type(F)=="table"then return i,F end end else break end end;return nil end
