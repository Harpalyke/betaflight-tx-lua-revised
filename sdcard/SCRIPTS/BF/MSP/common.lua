MSP_VERSION=bit32.lshift(1,5)MSP_STARTFLAG=bit32.lshift(1,4)local a=0;local b=0;local c={}local d=1;local e=0;local f=false;local g=0;local h={}local i=1;local j=0;local k=0;mspPendingRequest=false;function mspProcessTxQ()if#h==0 then return false end;if not protocol.push()then return true end;local l={}l[1]=a+MSP_VERSION;a=bit32.band(a+1,0x0F)if i==1 then l[1]=l[1]+MSP_STARTFLAG end;local m=2;while m<=protocol.maxTxBufferSize do if i>#h then break end;l[m]=h[i]i=i+1;j=bit32.bxor(j,l[m])m=m+1 end;if m<=protocol.maxTxBufferSize then l[m]=j;m=m+1;while m<=protocol.maxTxBufferSize do l[m]=0;m=m+1 end;if protocol.mspSend(l)then k=k+1 end;h={}i=1;j=0;return false end;if protocol.mspSend(l)then k=k+1 end;return true end;function mspSendRequest(n,l)if#h~=0 or not n then return nil end;h[1]=#l;h[2]=bit32.band(n,0xFF)for m=1,#l do h[m+2]=bit32.band(l[m],0xFF)end;g=n;return mspProcessTxQ()end;function mspReceivedReply(l)local o=1;local p=l[o]local q=bit32.band(p,0x20)~=0;o=o+1;if q then f=false;return nil end;local r=bit32.band(p,0x10)~=0;local s=bit32.band(p,0x0F)if r then d=1;c={}mspRxSize=l[o]e=bit32.bxor(mspRxSize,g)o=o+1;f=true elseif not f then mspOutOfOrder=mspOutOfOrder+1;return nil elseif bit32.band(b+1,0x0F)~=s then mspOutOfOrder=mspOutOfOrder+1;f=false;return nil end;while o<=protocol.maxRxBufferSize and d<=mspRxSize do c[d]=l[o]e=bit32.bxor(e,l[o])d=d+1;o=o+1 end;if o>protocol.maxRxBufferSize then b=s;return true end;if e~=l[o]then f=false;return nil end;f=false;return c end;function mspPollReply()while true do ret=protocol.mspPoll()if type(ret)=="table"then return g,ret else break end end;return nil end
